////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2022 Dimitry Ishenko
// Contact: dimitry (dot) ishenko (at) (gee) mail (dot) com
//
// Distributed under the GNU GPL license. See the LICENSE.md file for details.

////////////////////////////////////////////////////////////////////////////////
#ifndef ATEM_UTILS_HPP
#define ATEM_UTILS_HPP

////////////////////////////////////////////////////////////////////////////////
#include "types.hpp"

#include <tuple>
#include <type_traits>
#include <utility> // std::forward

////////////////////////////////////////////////////////////////////////////////
namespace atem
{

////////////////////////////////////////////////////////////////////////////////
// call function if it is not null
template<typename Fn, typename... Args,
    typename = std::enable_if_t< std::is_invocable_v<Fn, Args...> >
>
void maybe_call(const Fn& fn, Args... args)
{
    if(fn) fn(std::forward<Args>(args)...);
}

////////////////////////////////////////////////////////////////////////////////
constexpr auto to_uint8(char c) { return static_cast<uint8>(c); }
constexpr auto to_char(uint8 v) { return static_cast<char >(v); }

////////////////////////////////////////////////////////////////////////////////
constexpr auto to_uint16(char c0, char c1)
{
    return (static_cast<uint16>(to_uint8(c0)) << 8) | to_uint8(c1);
}

////////////////////////////////////////////////////////////////////////////////
constexpr auto to_chars(uint16 val)
{
    return std::make_tuple(to_char(val >> 8), to_char(val));
}

////////////////////////////////////////////////////////////////////////////////
}

////////////////////////////////////////////////////////////////////////////////
#endif
